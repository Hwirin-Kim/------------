//★★속성 존재 여부 확인
// 객체 내부에 어떤 속성이 있는지 확인해보는 코드
// 객체에 없는 속성에 접근하면 undefined가 나오는것을 이용!
// 조건문으로 undefined인지 확인하면 속성 존재 여부 확인 가능!

//이번시간 사용할 객체 !
const object = {
  name: "혼자 공부하는 자바스크립트",
  price: 18000,
  publisher: "한빛미디어",
};

if (object.name !== undefined) {
  console.log("name 속성이 있습니다."); //name 속성이 있습니다.
} else {
  console.log("name 속성이 없습니다.");
}
//name 속성이 있습니다.

//더 간단하게 표현 *** 단 false로 변환될 값이 없는 경우에만 사용
if (object.name) {
  console.log("name속성있음"); //name속성있음
} else {
  console.log("name속성없음");
}

//더 짧게 사용  *** 단 false로 변환될 값이 없는 경우에만 사용
object.name || console.log("name속성없음");
object.author || console.log("author속성없음"); //author속성없음
//이 경우 없는 경우에면 console 반환
//논리합 연산자는 좌변이 참이면 우변을 반환하지 않음!!

//객체 기본 속성 지정하기
object.name = object.name !== undefined ? object.name : "제목 미정";
object.author = object.author !== undefined ? object.author : "저자 미상";
console.log(object); //{name: '혼자 공부하는 자바스크립트',  price: 18000,publisher: '한빛미디어',author: '저자 미상'}

//객체 기본 속성 짧게 지정하는법
object.name = object.name || "제목 미정";
object.author = object.author || "작가 미상";
console.log(object); //{name: '혼자 공부하는 자바스크립트',  price: 18000,publisher: '한빛미디어',author: '저자 미상'}
//------------------------------------------------------------------------------------
//★★배열 기반의 다중 할당
// 다중할당 -->  [식별자, 식별자, 식별자, ....] = 배열

let [a, b] = [1, 2];
console.log(a, b);
// 1 2

[a, b] = [b, a]; //a와 b가 서로 교환됨
console.log(a, b);
// 2 1

//배열의 크기가 같을 필요는 없고, const 키워드로도 사용 가능
const arrayA = [1, 2, 3, 4, 5];
const [c, d, e] = arrayA;
console.log(c, d, e); // 1 2 3  같은 길이까지만 할당됨
//------------------------------------------------------------------------------------

//★★객체기반 다중 할당
//객체 속성 꺼내서 다중 할당
const obj = {
  name: "혼자 공부하는 자바스크립트",
  price: 18000,
  publisher: "한빛미디어",
};

//객체 속성 꺼내기
const { name, price } = obj;
console.log(name, price); //혼자 공부하는 자바스크립트   18000

//객체 속성을 다른이름으로 꺼내기
const { f = name, g = price } = obj;
console.log(f, g); //혼자 공부하는 자바스크립트   18000
//------------------------------------------------------------------------------------

//★★배열 전개 연산자

//얕은 복사 (참조 복사) : 주소만 참조하기 때문에 배열과 객체에서 발생하는 현상
const 물건_200301 = ["우유", "식빵"];
const 물건_200302 = 물건_200301; //복사 실행
물건_200302.push("고구마"); //복사한 곳에 고구마 추가
물건_200302.push("토마토"); //복사한 곳에 토마토 추가
console.log(물건_200301); //[ '우유', '식빵', '고구마', '토마토' ]  --> 원본도 바뀌어 버림
console.log(물건_200302); //[ '우유', '식빵', '고구마', '토마토' ]

//깊은 복사 : 완전히 다른 두 배열로 만듬, 전개연산자를 활용함
const 물건_200303 = ["우유", "식빵"];
const 물건_200304 = [...물건_200303]; //전개연산자 사용하여 복사
물건_200304.push("고구마"); //복사한 곳에 고구마 추가
물건_200304.push("토마토"); //복사한 곳에 토마토 추가
console.log(물건_200303); //[ '우유', '식빵' ]   ---> 원본은 그대로 있음!!
console.log(물건_200304); //[ '우유', '식빵', '고구마', '토마토' ]

//전개연산자를 활용하여 배열 요소 추가
const 물건_200305 = ["우유", "식빵"];
const 물건_200306 = ["고구마", ...물건_200305, "토마토"];
console.log(물건_200305); //[ '우유', '식빵' ]
console.log(물건_200306); //[ '고구마', '우유', '식빵', '토마토' ]  -->전개연산자 위치에 배열추가됨

//------------------------------------------------------------------------------------

//★★객체 전개 연산자

// 얕은 복사
const 구름 = {
  이름: "구름",
  나이: 6,
  종족: "강아지",
};
const 별 = 구름;
별.이름 = "별";
별.나이 = 1;
console.log(구름); //{ '이름': '별', '나이': 1, '종족': '강아지' } -->원본도 바뀌어 버림!!
console.log(별); //{ '이름': '별', '나이': 1, '종족': '강아지' }

//깊은 복사
const 해피 = {
  이름: "해피",
  나이: 61,
  종족: "강아지",
};
const 초코 = { ...구름 };
초코.이름 = "초코";
초코.나이 = 1;
console.log(해피); //{ '이름': '해피', '나이': 61, '종족': '강아지' } --> 바뀌지 않음!
console.log(초코); //{ '이름': '초코', '나이': 1, '종족': '강아지' }

//변경하고 싶은 속성만 추가
const 나비 = {
  이름: "나비",
  나이: 81,
  종족: "외계인",
};

const 벌 = {
  ...나비,
  이름: "벌", //기존속성을 이것으로 덮어씌움
  나이: 1, //기존속성을 이것으로 덮어씌움
  코로나백신: true, //새로운 요소 추가
};
console.log(나비); //{ '이름': '나비', '나이': 81, '종족': '외계인' }
console.log(벌); //{ '이름': '벌', '나이': 1, '종족': '외계인', '코로나백신': true } --> 이름과 나이는 바뀌고, 코로나백신여부 추가됨
